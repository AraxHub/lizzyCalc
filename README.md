# lizzyCalc

Обучалки по проекту: калькулятор с PostgreSQL и API-сервер.

---

# Часть 1. Калькулятор и PostgreSQL

Раздел про `cmd/main.go` и `cmd/docker-compose.yml`: бизнес-логика, работа с БД, Docker.

---

## Docker Compose

**Docker Compose** — способ описать и запустить несколько контейнеров одним файлом `docker-compose.yml`. В проекте один сервис — PostgreSQL.

- **version** — версия формата файла.
- **services** — список сервисов (контейнеров).
- **postgres** — имя сервиса; образ `postgres:15`, контейнер будет называться `lizzycalc_postgres`.

---

## Образ (image)

**Образ** — шаблон контейнера (ОС + софт). `postgres:15` — официальный образ PostgreSQL версии 15. При первом запуске образ скачивается из Docker Hub.

---

## Контейнер (container)

**Контейнер** — запущенный экземпляр образа. У контейнера есть имя (`container_name: lizzycalc_postgres`), он слушает порты и хранит данные в volume.

---

## Порты в Docker

В `ports: "5433:5432"`:

- **5432** — порт внутри контейнера (стандартный порт PostgreSQL).
- **5433** — порт на хосте. Подключение с машины: `localhost:5433`.

Так можно держать несколько PostgreSQL на одном хосте (например, 5433, 5434) и не конфликтовать со стандартным 5432.

---

## Переменные окружения (environment)

**environment** задаёт переменные окружения внутри контейнера. Для PostgreSQL обычно указывают:

- **POSTGRES_USER** — пользователь (у нас `postgres`).
- **POSTGRES_PASSWORD** — пароль (у нас `postgres`).
- **POSTGRES_DB** — имя базы при первом запуске (у нас `lizzycalc`).

Логин/пароль и имя БД нужны приложению в строке подключения.

---

## Volume (том)

**Volume** — постоянное хранилище данных контейнера. Без тома данные PostgreSQL пропали бы при удалении контейнера.

- `postgres_data:/var/lib/postgresql/data` — имя тома и путь внутри контейнера.
- В секции **volumes** объявляется `postgres_data`; Docker создаёт его и подставляет в сервис.

После перезапуска контейнера данные в БД сохраняются.

---

## Healthcheck

**healthcheck** — проверка, что сервис внутри контейнера уже готов принимать запросы.

- **test** — команда: `pg_isready -U postgres` (PostgreSQL готов?).
- **interval** — как часто проверять.
- **timeout** — таймаут одной проверки.
- **retries** — сколько раз подряд неудача считается нормой.

Используется при запуске зависимых сервисов (другой контейнер может ждать `healthy` перед стартом).

---

## Строка подключения к БД (connection string)

В коде строка подключения захардкожена:

```text
host=localhost port=5433 user=postgres password=postgres dbname=lizzycalc sslmode=disable
```

- **host** — где БД (localhost при запуске с хоста).
- **port** — 5433 (порт с хоста из `docker-compose`).
- **user** / **password** — как в `POSTGRES_USER` / `POSTGRES_PASSWORD`.
- **dbname** — как `POSTGRES_DB`.
- **sslmode=disable** — без SSL (нормально для локальной разработки).

---

## Подключение к БД (connectDB)

**connectDB** в коде:

1. Открывает соединение через `sql.Open("postgres", connStr)`.
2. Проверяет доступность через `db.Ping()`.
3. Возвращает `*sql.DB` — пул соединений к PostgreSQL.

`*sql.DB` потом передаётся в `saveOperation`, `getHistory`, `createTable`. Один пул на всё приложение — нормальная практика.

---

## Создание таблицы (createTable)

**createTable** выполняет SQL:

```sql
CREATE TABLE IF NOT EXISTS operations (...)
```

- **IF NOT EXISTS** — таблица создаётся только если её ещё нет; повторный запуск не падает.
- Поля: id (SERIAL), number1, number2, operation, result, message, timestamp. Так хранится одна запись о каждой операции калькулятора.

---

## Request и Operation (структуры)

- **Request** — входящий запрос на вычисление: два числа и операция (`+`, `-`, `*`, `/`). Не хранится в БД.
- **Operation** — полная запись об операции: входные данные, результат, сообщение, время. Именно она пишется в таблицу `operations` и читается в истории.

Разделение: запрос обрабатывается (usecase), результат и метаданные сохраняются как Operation.

---

## Usecase (бизнес-логика)

**calculateUsecase** — слой бизнес-логики:

- Принимает **Request**.
- По полю **Operation** выполняет арифметику (+, -, *, /), обрабатывает деление на ноль и неизвестную операцию.
- Возвращает сообщение (например, константа **success** — «Ответ рассчитан») и числовой результат.

Не знает про HTTP, БД и логи — только про вычисления. Так проще тестировать и менять.

---

## Сохранение в БД (saveOperation)

**saveOperation**:

- Принимает `*sql.DB`, исходный Request, сообщение и результат.
- Выполняет `INSERT INTO operations (...) VALUES ($1, ...) RETURNING id`.
- Плейсхолдеры `$1, $2, ...` защищают от SQL-инъекций и передают параметры из кода.
- **RETURNING id** возвращает присвоенный id; его можно залогировать.

Ошибки оборачиваются в `fmt.Errorf(..., err)` с `%w`, чтобы сохранялась цепочка ошибок.

---

## Чтение истории (getHistory)

**getHistory**:

- Выполняет `SELECT ... FROM operations ORDER BY timestamp DESC`.
- Обходит строки через `rows.Next()`, сканирует каждую в структуру **Operation**.
- Возвращает слайс `[]Operation` и ошибку.
- **defer rows.Close()** обязателен, чтобы не течь по соединениям.

История отдаётся от новых записей к старым.

---

## Константы success и errSaveOperation

- **success** — строка «Ответ рассчитан»; по ней в main проверяется, что usecase выполнился без ошибки.
- **errSaveOperation** — формат сообщения при ошибке сохранения в БД (`log.Printf(errSaveOperation, err)`). Вынесено в константу, чтобы не дублировать строку и не ошибиться в тексте.

---

## Цепочка в main

1. **connectDB()** — подключение к PostgreSQL (хост, порт, user, password, dbname из строки подключения).
2. **createTable(db)** — создание таблицы `operations` при необходимости.
3. Формируется **Request** (числа и операция).
4. **calculateUsecase(req)** — вычисление, получаем сообщение и результат.
5. По сообщению решаем, успех или ошибка; результат логируется.
6. **saveOperation(db, req, msg, result)** — запись в БД.
7. **getHistory(db)** — чтение всех операций из БД и вывод в лог.

Так в одной ветке кода сочетаются: конфиг (строка подключения), слой приложения (usecase), слой доступа к данным (save/get) и точка входа (main).

---

## Запуск

1. Поднять PostgreSQL:

```bash
cd cmd
docker-compose up -d
```

2. Запустить приложение (из корня репозитория):

```bash
go run cmd/main.go
```

Приложение подключится к БД на `localhost:5433`, создаст таблицу, выполнит запросы из кода и выведет историю из БД.

---

# Часть 2. API-сервер

Обучалка по API: сервер, хост, порт, роутер, ручка, группа роутов, middleware, версионирование — см. код `cmd/api/main.go` и комментарии в нём.

Кратко:

- **Сервер** — слушает адрес (хост + порт), отдаёт запросы в роутер.
- **Хост** (`0.0.0.0` / `localhost`) и **порт** (`8080`) — куда стучаться.
- **Роутер** — по методу и URL выбирает **ручку** (handler).
- **Группа роутов** — общий префикс (например, `/api/v1`, `/api/v2`) для набора маршрутов.
- **Версионирование** — v1 и v2 в URL; разный контракт ответа без поломки старых клиентов.
- **Middleware** — общий код до/после ручек (логирование, recovery).

Запуск API: `go run cmd/api/main.go`. Проверка: `curl http://localhost:8080/api/v1/health` и `curl http://localhost:8080/api/v2/health`.
