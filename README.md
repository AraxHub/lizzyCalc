# lizzyCalc

## Makefile: как юзать и зачем так

После смены ветки окружение должно соответствовать **текущей** ветке: на одной — только postgres + calculator, на другой — ещё redis, redisinsight, кафка и т.д. Состав сервисов задаётся в `deployment/localCalc/docker-compose.yml` и `deployment/frontend/docker-compose.yml` **на этой ветке**. Если не пересобрать образы и не перезапустить контейнеры, можно получить старые образы с другой ветки или конфликты имён. Поэтому смена ветки = явная пересборка.

Makefile в корне репо даёт одну точку входа: из корня вызываешь `make backend` и/или `make frontend` — не нужно помнить пути к compose и флаги.

### Как это устроено

- **Make** читает `Makefile`, видит цели (targets): `backend`, `frontend`, `backend-down` и т.д.
- Цель без аргументов (просто `make`) по умолчанию — первая в файле; у нас это `help`, так что `make` и `make help` показывают подсказку.
- У цели могут быть зависимости. Например, `backend` зависит от `backend-down`, `backend-build`, `backend-up` — make выполняет их по порядку.
- Команды в рецепте каждой цели выполняются в shell; `cd ... &&` нужен, потому что каждый рецепт — отдельная оболочка, и без `cd` команды шли бы из корня репо.

Почему именно так:

- **`down --rmi local`** — останавливает контейнеры и удаляет образы, собранные **этим** compose (с тегом проекта), а не все образы в системе. Так мы избавляемся от старых образов текущего проекта.
- **`build --no-cache`** — сборка без кэша, в образ попадает код текущей ветки, а не закэшированные слои со старой.
- **Отдельный проект для фронта** (`-p lizzycalc-frontend`) — бэкенд и фронт поднимаются разными compose, не мешают друг другу и могут пересобираться по отдельности.
- **`docker rm -f lizzycalc-frontend`** во фронте — на случай «зомби» контейнера с таким именем, который мешает созданию нового после `down`.

### Бэкенд (postgres + calculator; на части веток — redis, redisinsight и т.д.)

Из **корня репо**:

| Команда | Что делает |
|--------|------------|
| `make backend` | Остановить контейнеры и удалить образы → собрать образы без кэша → поднять контейнеры (`up -d`). Основной сценарий после `git checkout ...`. |
| `make backend-down` | Только остановить и удалить образы. Без `-v` тома (в т.ч. данные БД) сохраняются. |
| `make backend-down DROP_VOLUMES=1` | То же, но с `-v` — удаляются и тома. Удобно, когда хочешь чистую БД и видеть наполнение с нуля. |
| `make backend DROP_VOLUMES=1` | Полный цикл пересборки бэкенда **с удалением томов** (БД обнулится). |
| `make backend-build` | Только сборка образов без кэша. |
| `make backend-up` | Только поднять контейнеры (если уже собрано). |

Состав сервисов всегда тот, что в `deployment/localCalc/docker-compose.yml` на текущей ветке.

### Фронт (отдельный compose)

Фронт не поднимает бэкенд; ожидается уже запущенный бэкенд (локально или в контейнере). Из **корня репо**:

| Команда | Что делает |
|--------|------------|
| `make frontend` | Down → принудительно удалить контейнер `lizzycalc-frontend`, если остался → build --no-cache → up -d. Используй после смены ветки, если на ветке есть фронт и он нужен. |
| `make frontend-down` | Остановить и удалить образы фронта + попытаться удалить контейнер по имени. |
| `make frontend-build` | Только собрать образ без кэша. |
| `make frontend-up` | Только поднять контейнер фронта. |

### Примеры

Перешёл на ветку с redis и т.д.:

```bash
git checkout feature-redis-cache
make backend
make frontend   # при необходимости
```

Перешёл на ветку только с postgres + calculator, хочешь снести данные БД:

```bash
git checkout feature-frontend
make backend DROP_VOLUMES=1
make frontend
```

Подсказка по всем целям:

```bash
make
# или
make help
```
