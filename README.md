# lizzyCalc

Документация по проделанной работе в этой ветке: что есть в `cmd/main.go`, как устроены слои и когда слайс станет базой данных.

---

## Что сделано в этой ветке

- Калькулятор: два числа + операция (+, -, *, /), результат и сообщение.
- Бизнес-логика вынесена в один usecase.
- История операций хранится в памяти (слайс) — это временное хранилище, «аналог БД».
- Запросы в main создаются вручную (имитация клиентов), каждый обрабатывается через usecase, в конце выводится история.

Нет HTTP, нет реальной БД — только логика, контракт данных и место, куда потом подставить базу.

---

## Что есть в коде по частям

### Структуры (модели)

**Request** — входящий запрос на одну операцию: `Number1`, `Number2`, `Operation`. То, что приходит «от клиента» (сейчас из main).

**Operation** — полная запись об операции: те же два числа и операция плюс `Result`, `Message`, `Timestamp`. То, что мы сохраняем в историю. Одна такая структура = одна строка в будущей таблице БД.

### Константы

**success** — строка «Ответ рассчитан». По ней в main понимаем, что usecase выполнился без ошибки; иначе — ошибка (деление на ноль, неизвестная операция).

### Хранилище (сейчас — слайс)

**operations** — глобальный слайс `[]Operation`. Сейчас это единственное хранилище истории: каждая выполненная операция добавляется сюда в usecase. Данные живут только пока работает процесс; после перезапуска история пустая.

В документе и в коде это явно названо «аналог БД»: те же данные, тот же смысл, что будет в таблице, только пока в памяти.

### Бизнес-логика (usecase)

**calculateUsecase(req Request) (string, float64)** — считает результат по запросу и возвращает сообщение и число. Внутри:
- по `req.Operation` выбирается арифметика (+, -, *, /), обрабатываются деление на ноль и неизвестная операция;
- формируется запись `Operation` и добавляется в слайс `operations`;
- возвращается сообщение (success или текст ошибки) и результат.

Слой usecase не знает про HTTP и про то, что «БД» пока слайс. Позже сохранение можно вынести в отдельный слой репозитория, а usecase будет только считать и возвращать результат; тогда замена слайса на БД затронет только репозиторий.

### Вывод истории

**history()** — читает слайс `operations` и выводит в консоль все операции по порядку (номер, числа, операция, результат, статус, время). Сейчас это единственное «чтение» из хранилища; позже то же самое будет делать запрос к БД и отдавать те же структуры `Operation`.

### Точка входа

**main()** — имитирует приход запросов: создаёт несколько `Request` вручную, по одному вызывает `calculateUsecase`, по сообщению печатает результат или ошибку, в конце вызывает `history()`. Так проверяется цепочка: запрос → usecase → сохранение в слайс → вывод истории.

---

## Слои и где будет база

- **Бизнес-логика** — `calculateUsecase`: только вычисления и правила (деление на ноль и т.д.). Сюда не лезем при переходе на БД.
- **Хранилище** — сейчас это слайс `operations` и код, который в него пишет (в usecase) и читает (в `history`). Это и есть слой, который «станет базой».
- **Точка входа** — main: создаёт запросы, вызывает usecase, выводит историю. Позже сюда может добавиться HTTP (handlers будут вызывать тот же usecase) или подключение к БД при старте.

Когда станет базой:
- Вместо глобального слайса заводится репозиторий (например, структура с полем `*sql.DB` или интерфейс `SaveOperation` / `GetHistory`).
- Сохранение одной операции: не `operations = append(...)`, а `INSERT INTO operations (...) VALUES (...)`.
- Чтение истории: не обход слайса в `history()`, а `SELECT ... FROM operations ORDER BY ...` и заполнение `[]Operation`.
- Структура `Operation` остаётся той же; меняется только реализация «сохранить» и «прочитать». Usecase и контракт запроса/ответа можно не трогать.

Итого: «что есть что» — модели (Request, Operation), константа success, хранилище (слайс operations), usecase (расчёт + пока запись в слайс), вывод истории, main (ручные запросы). «Когда станет базой» — когда слой хранилища перепишут на работу с PostgreSQL (или другой БД), не меняя usecase и структуры данных.
