# lizzyCalc

Обучалка по API-серверу: основные понятия на примере `cmd/api/main.go`.

---

## Сервер (Server)

**Сервер** — программа, которая слушает сетевой адрес (хост + порт) и принимает входящие HTTP-запросы. В коде это `http.Server`: он знает, на каком адресе слушать и какой **обработчик** (роутер) использовать для каждого запроса.

```go
server := &http.Server{
    Addr:    serverHost + ":" + serverPort,
    Handler: router,
    // ...
}
server.ListenAndServe()
```

---

## Хост (Host)

**Хост** — сетевое имя или IP, по которому доступен сервер.

- `localhost` или `127.0.0.1` — только с этой машины.
- `0.0.0.0` — слушать на всех интерфейсах (доступ с других машин в сети).

В проекте: `serverHost := "0.0.0.0"` — сервер принимает запросы с любого интерфейса.

---

## Порт (Port)

**Порт** — число (1–65535), которое вместе с хостом образует адрес сервиса. Один хост может отдавать разные сервисы на разных портах.

- `80` — стандартный HTTP.
- `443` — HTTPS.
- `8080` — часто используют для разработки вместо 80.

В проекте: `serverPort := "8080"`. Полный адрес сервера: `http://localhost:8080` или `http://0.0.0.0:8080`.

---

## Роутер (Router)

**Роутер** — компонент, который по URL и методу HTTP (GET, POST и т.д.) решает, какую **ручку** вызвать. В Gin роутер — это `*gin.Engine`, создаётся через `gin.New()`.

Роутер хранит таблицу маршрутов вида: «GET /api/v1/health → healthHandler». Запрос приходит → роутер находит подходящий маршрут → вызывается соответствующая ручка.

---

## Ручка (Handler)

**Ручка** (handler) — функция, которая обрабатывает один тип запроса: читает тело/параметры и формирует ответ (например, JSON и статус 200).

В Gin ручка имеет вид:

```go
func handler(c *gin.Context) {
    c.JSON(http.StatusOK, data)
}
```

`c *gin.Context` — контекст запроса (URL, заголовки, тело, метод). В проекте: `healthHandler` и `healthHandlerV2` — ручки для `/health` в v1 и v2.

---

## Группа роутов (Route Group)

**Группа роутов** — общий префикс URL для набора маршрутов. Удобно для версионирования и разбиения API.

```go
apiV1 := r.Group("/api/v1")
apiV1.GET("/health", healthHandler)  // → GET /api/v1/health

apiV2 := r.Group("/api/v2")
apiV2.GET("/health", healthHandlerV2) // → GET /api/v2/health
```

Все маршруты в группе автоматически получают префикс группы. Можно вешать **middleware** на группу — они применятся только к маршрутам этой группы.

---

## Версионирование API (API Versioning)

**Версионирование** — поддержка нескольких версий API одновременно. Клиент выбирает версию через URL: `/api/v1/...` или `/api/v2/...`.

- **v1** — стабильный контракт для старых клиентов.
- **v2** — новые поля и поведение без поломки v1.

В проекте: v1 отдаёт минимальный health, v2 — расширенный (uptime, metadata, версия). Один и тот же «логический» эндпоинт (`/health`) в разных версиях может возвращать разный формат ответа.

---

## Middleware

**Middleware** — код, который выполняется до или после ручки для каждого запроса (логирование, паника, авторизация, CORS и т.д.). Один middleware обрабатывает много маршрутов.

В коде:

- `gin.Logger()` — пишет в лог метод, путь, статус и время обработки.
- `gin.Recovery()` — ловит панику в ручках, логирует и отдаёт 500 вместо падения процесса.

Подключение к роутеру:

```go
r.Use(gin.Logger())
r.Use(gin.Recovery())
```

Все запросы, проходящие через этот роутер, сначала проходят через эти middleware, затем попадают в ручку.

---

## Маршрут (Route)

**Маршрут** — правило «метод + путь URL → ручка». Регистрация в Gin:

- `r.GET("/path", handler)` — GET-запросы на `/path`.
- `apiV1.GET("/health", healthHandler)` — GET на `/api/v1/health`.

Маршруты проверяются в порядке регистрации; первое совпадение определяет ручку.

---

## Эндпоинт (Endpoint)

**Эндпоинт** — конкретный URL (часто вместе с методом), по которому клиент обращается к API. В проекте эндпоинты:

- `GET /` — информация о сервисе.
- `GET /api/v1/health` — health v1.
- `GET /api/v2/health` — health v2 (расширенный).

---

## Как это связано в одном запросе

1. Клиент шлёт запрос: `GET http://localhost:8080/api/v2/health`.
2. **Сервер** принимает его на **хосте** `0.0.0.0` и **порту** `8080`.
3. **Роутер** по методу и пути выбирает маршрут (группа `api/v2`, путь `/health`).
4. Выполняются **middleware** (Logger, Recovery).
5. Вызывается **ручка** `healthHandlerV2`, она формирует ответ и вызывает `c.JSON(200, ...)`.
6. Клиент получает ответ с телом и статусом 200.

---

## Запуск API

```bash
go run cmd/api/main.go
```

Проверка:

- `curl http://localhost:8080/`
- `curl http://localhost:8080/api/v1/health`
- `curl http://localhost:8080/api/v2/health`
