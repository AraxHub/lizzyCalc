# lizzyCalc

Калькулятор: Go (Clean Architecture), PostgreSQL, Redis, React.

---

## Кэш: устройство по слоям и бизнес-задача

### Бизнес-задача

Кэш снижает нагрузку на БД и сохраняет историю операций **осмысленной**: в БД попадает **каждая уникальная операция по одному разу** (первый запрос), повторные запросы с теми же операндами и действием отдаются из кэша **без записи в БД**. История тогда отражает «что считали» (распределение операций, аналитика), а не каждый повторный клик. В проде это даёт меньше записей, меньшую нагрузку на БД и быстрый ответ на частые одинаковые запросы.

### Устройство по слоям

- **ports** (`internal/ports/cache.go`)  
  Интерфейс **Cache**: `Get(ctx, key) (value float64, found bool, err error)` и `Set(ctx, key, value float64) error`. Ключ — строка операции, значение — результат. Контракт не привязан к Redis.

- **usecase** (`internal/usecase/calculator/`)  
  В **Calculate**: по `number1`, `number2`, `operation` формируется читаемый ключ (например, `"1 + 1"`). Сначала вызывается `cache.Get(key)`. При попадании — возвращается результат из кэша, в БД и расчёт не идёт. При промахе — выполняется расчёт, результат сохраняется в репозиторий (БД), затем кладётся в кэш (`cache.Set`), после чего возвращается ответ.  
  **History** кэш не использует: история всегда читается из БД через `repo.GetHistory`.

- **infrastructure** (`internal/infrastructure/redis/`)  
  **module.go**: подключение к Redis (конфиг, клиент, `Ping`).  
  **cache.go**: реализация **ports.Cache** поверх Redis: ключ — строка, значение — результат в виде строки (float64). Ключи уникальны, повторный Set перезаписывает значение.

Итого: порт задаёт контракт кэша, usecase решает «сначала кэш, при промахе — расчёт + БД + кэш», инфраструктура даёт реализацию для Redis.
