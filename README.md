# lizzyCalc

Документация по `cmd/main.go`: слои приложения и куда что класть в будущем.

---

## Слои приложения

Код разбит на три слоя. Понимание, что к чему относится, помогает не путать логику и легко менять хранилище или API.

```
  HTTP (handlers)  →  бизнес-логика (usecase)  →  хранилище (репозиторий)
       │                        │                            │
  парсинг JSON,            вычисления,                  куда пишем
  статусы ответов          правила операций              и откуда читаем
```

---

## 1. Бизнес-логика (usecase)

**Где в коде:** функция `calculateUsecase`.

**Что делает:** считает результат по двум числам и операции (+, -, *, /). Знает только про числа и операции, не про HTTP и не про то, куда сохранять.

**Сейчас:** внутри usecase ещё есть запись в слайс `operations`. По идее слой репозитория должен быть отдельно; ниже описано, как разделить.

**В будущем сюда:** новые операции, валидация входных данных (например, лимиты на числа), любые правила расчёта. Без привязки к HTTP и БД.

---

## 2. Слой репозитория (хранилище)

**Где в коде:** глобальный слайс `var operations []Operation` и код, который в него пишет/читает.

- **Писать:** в `calculateUsecase` строки с `Operation{...}` и `operations = append(operations, operation)`.
- **Читать:** в `historyHandler` — `len(operations)`, `operations` в ответе.

**Что это:** «аналог БД» — место, где лежит история операций. Сейчас это память (слайс); завтра может быть PostgreSQL, файл, другой сервис.

**В будущем:** вынести в отдельные функции/тип, например:
- `SaveOperation(op Operation) error`
- `GetHistory() ([]Operation, error)`

Тогда usecase и хэндлеры будут вызывать только эти функции и не знать, слайс это или БД. Замена слайса на БД делается только в репозитории.

---

## 3. Слой HTTP (handlers)

**Где в коде:** `calculateHandler`, `historyHandler`.

**Что делают:**
- Принимают запрос (парсят JSON через `ShouldBindJSON`).
- Вызывают usecase или читают данные (пока напрямую из слайса).
- Отвечают клиенту: статус 200/400 и тело (JSON).

**В будущем сюда:** только про HTTP: форматы запроса/ответа, коды ошибок, middleware (логирование, авторизация). Без правил расчёта и без знания, как именно хранятся операции.

---

## Модели (структуры)

**Request** — входящий запрос на вычисление. Используется в хэндлере и usecase. Поля с `json:"..."` для парсинга из JSON.

**Operation** — одна запись об операции (входные данные + результат + сообщение + время). Используется в usecase и при отдаче истории. Это то, что «живёт» в хранилище.

**Response** — ответ клиенту по одному вычислению (result или error). Только для HTTP-слоя.

Итого: Request/Response — контракт API; Operation — сущность домена и хранилища.

---

## Как связаны слои в запросе

**POST /calculate:**
1. **Handler** парсит JSON в `Request`, при ошибке — 400.
2. **Handler** вызывает `calculateUsecase(req)`.
3. **Usecase** считает результат и сообщение; сейчас же сам дописывает запись в слайс (по сути репозиторий).
4. **Handler** по сообщению решает: 200 + результат или 400 + текст ошибки, формирует `Response`.

**GET /history:**
1. **Handler** читает данные (сейчас напрямую слайс `operations`).
2. **Handler** отдаёт 200 и JSON с count и operations.

В более чистом варианте: handler вызывает usecase или репозиторий (GetHistory), а не обращается к слайсу сам.

---

## Куда что добавлять в будущем

| Задача | Слой |
|--------|------|
| Новая операция (например, степень) | Бизнес-логика: `calculateUsecase` |
| Валидация (числа в диапазоне, операция из списка) | Бизнес-логика или отдельный валидатор перед usecase |
| Сохранение в PostgreSQL вместо слайса | Репозиторий: заменить слайс на вызовы БД |
| Кэш, ещё одно хранилище | Репозиторий: новые функции или реализация того же интерфейса |
| Новый формат ответа, другой статус при ошибке | HTTP: handlers |
| Логирование запросов, проверка токена | HTTP: middleware |
| Новый эндпоинт (например, GET /operation/:id) | HTTP: новый handler + при необходимости usecase/репозиторий |

Так человек, открывший проект позже, понимает: бизнес-логика — в usecase, работа с данными — в репозитории, всё про протокол и контракт API — в handlers.
